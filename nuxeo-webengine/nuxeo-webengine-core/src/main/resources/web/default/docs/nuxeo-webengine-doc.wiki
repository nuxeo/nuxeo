
= Nuxeo WebEngine

{toc}{/toc}

The WebEngine is a framework to build web applications on top of the Nuxeo EP platform.

== Overview

The main goal for the WebEngine framework is to let users build web applications quickly and easily and in a traditional way, without having knowledge on advanced Java topics such as JSF or Seam.

The second goal is to be able to update the application while the server is running, without the need of restarting the server each time the configuration or the code is modified.

The web pages are build using FreeMarker templates for the presentation part and optionally scripts (like Groovy, Jython etc) or custom Java request handlers for the logical part.

Thus, a web application is made from:
+ *Configuration* - based on the nuxeo extension points mechanism.
+ *Templates* - FreeMarker is used as the template engine.
+ *Scripts* - any script supported by the Java scripting engine.
+ *Custom Java Code* - plugged-in through extension points.

Here is an example of a simple template page

{{{My name is ${Context.principal.name}!}}}

that will output when called:

{{{My name is Administrator!}}}

if you are logged in as __Administrator__.

The same can be done from a script (in this example a groovy script):

{{{
Context.print("My name is ${Context.principal.name}")!
}}}

=== Bridging with Nuxeo EP

The WebEngine was created to work over a Nuxeo EP server. Using it outside Nuxeo EP is possible, but is very limiting and you will loose many of the cool features of the WebEngine.

If you don't plan to use a Nuxeo EP server as the content backend for your web site or Web 2.0 application, we suggest you to look at other products that may better fit your needs:
* Django
* Ruby on Rails
* etc.

In this section we will assume you have some knowledge about the Nuxeo EP platform.

Nuxeo EP, as its name suggests, is an Enterprise Content Management platform that provides a powerful way to manage and store your documents. For simplicity you can see Nuxeo EP as a document repository. To use access the repository, to update, query or to store new documents, you need first to connect to it and create an authenticated session based on your login information. Using that repository session you can then start querying, updating and sorting documents.

So, from a client point of view, the main concepts of a Nuxeo Repository are the Session (the user connection to the repository) and the Document (the units of information that are managed by the repository).

The idea behind the WebEngine is to map HTTP requests to documents stored in the repository and to be able that way to query, update, store or create new documents by using a traditional Web approach.

To correctly understand how this bridging over Nuxeo EP is done and what you can do by using WebEngine, you should first understand how HTTP requests are dispatched, processed and mapped to documents.

=== Request Dispatch

We will start using a simple example. Let's say the client is requesting the following URL:
`http://www.nuxeo.org/nuxeo/site/repository/blogs/bstefanescu/MyBlog@@view`

First the URL will be split as following:
* `http://www.nuxeo.org` - the server host information
* `/nuxeo/site` - the servlet context path. This corresponds to the Java context path + servlet path. As we are in Java world, we are obviously using Java servlets under the hoods. The WebEngine is bound on an unique servlet in a Web Application. You cannot have multiple WebEngines in the same Web Application. If you want to partition your WebEngine sites into different applications you need to use the WebEngine Application concept as we will see later.

In the standalone packaging of WebEngine (based on Jetty) the servlet context path is the root one: "/".
* `/repository` - the WebEngine application path. This path is used to select the WebEgnine application you want.
* `/blogs/bstefanescu/MyBlog` - the traversal path. This path is used to select the document or script you want to call.
* `@@view` - the action to take on the selected object. The action is optional and, if omited when requesting Documents, the implicit action is `@@view`.

The first 2 URL components are not in the scope of this document. They are used to locate the servlet bound to the WebEngine application.

We will focus on the last three URL parts:

+ Application path
+ Traversal path
+ Action

The path formed by the concatenation of the Application path and the Traversal path will be named the *Request Path*.

==== Application Path

The application path is used to select which WebEngine application to use. WebEngine applications are useful to isolate the different sites you want to host. A single application may define several application paths. When defining an application path you can optionally specify a repository Document that will be selected as the root document when an application is selected.

More details about this in the WebEngine Application section.

==== Traversal Path

The traversal path represent the path that should be processed and resolved by the selected web application. If the application path used to select the application defined a Document root then the application will try to map the traversal path to a Document or a chain of Documents in the repository. If the application path is not bound to a Document root then the application will try to resolve the traversal path to a script or template on the file system. If neither of these methods succeeds an error page (along with a 404 error code) is sent to the client.

*Note* that in future it will be possible to bound an application path to an arbitrary root Object that is not necessarily a Document in the repository but that will know how to resolve the traversal path into a chain of arbitrary objects (not necessarily Documents). This is useful for example to map a traversal path on an User, Group or other objects managed by Nuxeo EP.

The default technique to resolve traversal paths into a chain of Documents is using a direct mapping between this path and a repository path starting from the root Document. The mapping technique is configurable and can be changed by implementing the `org.nuxeo.ecm.webengine.RequestHandler` interface.

Lets give an example on how the default mapping works.

Lets say you defined an application bound to an application path of `/repository` in the context of a WebEngine instance that is bound to a servlet accessible at `http://localhost:8080/nuxeo/site`.  So, a request of the form `http://localhost:8080/nuxeo/site/repository/foo/bar` will be resolved against your application and the URL will be split as following:

+ `http://localhost:8080` - host server
+ `/nuxeo/site` - WebEngine context path (the root context)
+ `/repository` - the application path
+ `/foo/bar` - the traversal path

Lets say your application path `repository` defines a root document that points to `/default-domain/workspaces/MyWorkspace` (this is a repository path).
Then the application will try to resolve the `/foo/bar` path as a repository path starting from the root Document. So the selected document (the target document of the request) will be one of:

* `/default-domain/workspaces/MyWorkspace` - the root itself
* `/default-domain/workspaces/MyWorkspace/foo` - if `foo` is resolved as a child document of the root but `bar` is not resolved as a child document of `foo`
* `/default-domain/workspaces/MyWorkspace/foo/bar` - if both `foo` and `bar` are resolved as child documents

Let say `foo` is a child of `/default-domain/workspaces/MyWorkspace` and `bar` could not be resolved as a child document of `foo`. Then the traversal path will be resolved to `/default-domain/workspaces/MyWorkspace/foo` that will point to a document called the *Target Document* (or Context Document) and the remaining segments (the unresolved segments) will define the *trailing path* - in our case `/bar`. The chain of Documents that were obtained by mapping the traversal path is known as the *traversal objects*.

==== Trailing Path

As we've seen the trailing path contains the `residual` segments after a mapping on a Document is done. Obviously it will be empty if all segments from the traversal path are mapped to documents. Anyway, such 'residual' path segments are not garbage but they may give some extra information on how to perform the request. How the trailing path is used by the server is depending on the action or script that will be executed on the Target Document. There isn't any default behavior in handling such a trailing path. It is up to the developer how this path is used.

For example, a possible usage is to map the trailing path on an XPATH that point to a Document property. So in our previous example the trailing path `/bar` will point to a property `bar` in the document `foo`. This can be used to create paths to set or get properties on documents. Example:
`/default-domain/workspaces/MyWorkspace/foo/bar@@set?value=test` 

==== Actions

The action string represent an action to be taken on the last resolved document (or the target document).

An action can be bound to a Java class (an action handler) or to a script in order to perform the wanted operation on the document.
If no action is specified in the request URL then a default action `@@view` will be used.

*Note* that in future the `action` concept will be extended. For now actions are used when requesting Documents. They are ignored when the request is not resolved to a document but to a script or template. (e.g. if you are using pure scripting that are not resolved to Nuxeo EP Documents). In future the action mechanism will be extended to be used on any type of resource. For example in the case of scripts an `action` may be mapped on a script function.

You can find more details on actions in Web Application : Actions section

=== Path Mapping

We already seen how the request URL is transformed into these components:
+ host server
+ servlet context
+ application path
+ traversal path
+ an optional trailing path
+ an optional action

In the examples above we've seen how a traversal path was mapped on documents. But what if we need more control on the mapping mechanism? As we said one solution (but harder) is to write a custom request handler that is doing the job. Another solution that doesn't requires any additional Java code is to use path mappings.

Mappings can be used to declaratively describe how traversal paths should be processed to obtain a document chain, a trailing path and additional properties computed from the path segments configuration. Mappings are described using regular expression patterns. The regular expression syntax is the Java one with an additional feature to be able to define named groups. (In Java only indexed groups are supported).

In order to understand how you can use patterns to describe the path mapping we will start with another example.

Lets say we want to use the following URL path:

`/blogs/archive/2004/05`

to display a list of the blogs of user `bstefanescu` created in May 2004. Lets say that we define an application path `/blogs` that specify a root Document `/default-domain/workspaces/blogs` where are stored the blogs in the repository.

So by using a `/blogs` prefix in the URL path we will select the correct application so that we have the root `/default-domain/workspaces/blogs`.
Then, we want to use a script that will be invoked in the context of the root document to perform a search like:
{{{SELECT * FROM Blog WHERE ecm:path STARTSWITH ${blogs} AND dc:created >= DATE '$year-$month-01'}}}
to select all the blog documents created after the given date and located under the `${blogs}` document.
For this we need to extract from the input the year and the month information. We already known the `${blogs}` variable since it is the target document of the request (in our case it is the same as the selected application root).
In order to do this we need to define the following mapping:

{{{/blogs/archive/(?year:[0-9]{4}?)/(?month:[0-9]{2}?)}}}

This mapping is matching any path in the desired format and will inject in the request context the variables `${year}` and `${month}`. This way the script can grab them from the context and run the query.

The syntax (?label: ... ) for regular expression groups is an extension to the Java regular expressions that are supporting only indexed groups. You can still use the indexed groups if you prefer:

`/blogs/archive/([0-9]{4}?)/([0-9]{2}?)`

In this case the generated mapping variables will be `$1` for the year and `$2` for the month.

You may note that using mappings or using a custom request handler that avoid mapping path segments on documents you may create web application that doesn't use any Nuxeo repository.

=== Directory Layout - Resolving Scripts and Templates 

All WebEngine application files are residing under a common root folder named the web folder. This folder is located in `${nxserver}/web` folder in the standalone version. On JBoss the web root folder is located in `${jboss_install_dir}/server/default/data/NXRuntime/web`.

An application may have multiple roots folders where scripts and other files are residing. When resolving scripts from paths each of these folders are consulted in turn until a matching file is found.

Example: Let say you have an web application that contains two roots: `wiki` and `default` (in that order). So inside the `web` directory we will have `web/wiki` and `web/default`.

When resolving a path let say `/commons/myscript.py` the web application will look first in `wiki` folder for a file path `commons/myscript.py` and then if none was found it looks for the same path in the `default` folder. 

This mechanism is completely described in the Directory Stacking section.

Note that the paths `/commons/myscript.py` and `commons/myscript.py` are equivalent. Both of them will be resolved relative to the Web Application root folders.

If you need to use relative paths (relative to the current executed script or template) you must prepend a '.' or a '..' on the path to force the path resolver to use the current script as the file base.

Example of relative paths:
* ../../myscript.py
* ./myscript.groovy

Note that using relative paths is less efficient since the path lookup cannot be cached because the current directory used to resolve scripts depends on the current request context, context that is changing on each request or more may change during the same request.

Also when a relative path points outside the web root directory then it will be truncated (i.e. trailing ../ removed) and resolved as an absolute path.

==== Resolving Action Scripts

When writing scripts or templates to handle request actions we usually want to treat the target documents of same type in the same manner. For example a `Folder` document will be always displayed as a folder, a `File` document as a file and so on.

So we need a mechanism to select the template or the script associated to an action depending on the target document type.

Note that this selection mechanism make sense only for document action scripts. It doesn't make sense for plain scripts (that are not bound to documents) since in this case you may not have a target document.

This aspect was solved by using a very simple and intuitive mechanism based on folder names:

Each application root folder may contain a sub-folder for each document type. This sub folder should use the same name as the document type.

This way each time an action script is resolved the resolver will look in the folder having the same name as the target document type. If it doesn't find any matching file it is looking in the folder corresponding to the super type of the current document type and so on. This lookup stops when a matching file is found or when no more super types exists.

As the `Document` type is the base types of all Nuxeo document types you may put in that folder the default files for every document action.

If no file matches then a default file (a fallback file) will be used to display a custom message. This default file is configurable at the application level. If the default file cannot be fond or was not defined then a 404 is send to the client.

Example: In the `default` application root you may have three folders:
* Document
* Folder
* Wiki

Let say you want to call the script bound to the `@@view` action of a `Wiki` document. Then the script resolver will first look into `Wiki` folder then if nothing is found and because `Wiki` is extending `Folder` it will look into `Folder` folder and then if nothing is found as `Folder` is extending `Document` it will look into Document folder. Finally if nothing is found the registered default script if any is used.

*Note* that when you have multiple web application roots this mechanism will searching the script in each root in turn until something is found.

== Getting Started

WebEngine is shipped in two flavors:
* a standalone server
* a Nuxeo EP module, that runs in a JBoss application server

Both of these versions provides the same functionalities and the same JARs are used on both platforms.
This is possible since WebEngine is build over the Nuxeo Runtime layer that works over any OSGi platform.
In both standalone and JBoss versions the OSGi framework is emulated by a Nuxeo component: `nuxeo-runtime-osgi`.

WebEngine is working on any platform supported by Nuxeo EP (UNIX-like systems, MAC OS X, Windows). Anyway in the case of MAC OS X there is a known problem and to be able to start WebEngine you need to remove the file `System/Library/Java/Extensions/AppleScriptEngine.jar` file.

=== Standalone server

The standalone server is the *light* version of WebEngine and doesn't requires an application server to work.

This means that Nuxeo services required by WebEngine are not exposed as session beans. Anyway, all of the functionalities present in the JBoss version are available in the standalone server.

The light version is embedding a Jetty HTTP server and by default binds the WebEngine instance to the root web context: `/`.

In the future, we plan to also provide a light version of WebEngine that will embed a GlassFish v3 server.

The light version is very useful for developing since the startup time is very fast (e.g. 2-3 seconds on my laptop using Java 6) - but can be also used in production.

==== Installation

To install the light version, download it from http://nuxeo.org/projects/webengine, unzip the content into a folder of your choice, and run `nxserver.sh` to launch the application. Then go to http://localhost:8080.

==== Launcher

To start WebEngine, simply run `./nxserver.sh` on linux or `nxserver.cmd` on windows.

The common options are:

* `-debug` - to start in debug mode. In this mode the launcher will wait for a Java debuger to connect.
* `-clear` - to cleanup cache before starting. This is needed if you add a JAR into `bundles` or `lib` directories - since the launcher is caching the classpath at the first start of the server.
* `-console` - to activate the server administration console

For more information on the launcher look into `nxserver.sh`

==== Requirements

* Java 5 or later - WebEngine is working fine on both Java 5 and 6.

=== Nuxeo EP module

WebEngine can be deployed as a Nuxeo EP module on a running Nuxeo server (that currently supports JBoss as application server).

In this version, WebEgnine is bound by default to the `/nuxeo/site` context path.

When deployed as a Nuxeo EP module, WebEngine will run in an application server so all required Nuxeo services will be exposed as session beans.

==== Installation

Install a Nuxeo EP product. Download the webengine components from http://www.nuxeo.org/projects/webengine:
* nuxeo-platform-rendering
* nuxeo-webengine-core
* nuxeo-webengine-wiki (optional)

Copy these JARs inside `nuxeo.ear/plugins`.

Make sure you have nuxeo-runtime-scripting in your nuxeo.ear/system folder if not download and copy it into this folder.

Make sure you have the following JARs in your `nuxeo.ear/libs`:
* freemarker-2.3.11.jar
* json-lib-2.2.1-jdk15.jar
* ezmorph-0.9.jar

If they are not there, download them and copy into the `libs` folder (overwriting older versions if any)

In order to use Anonymous login you also need to deploy the optional Nuxeo EP module: `nuxeo-platform-anonymous-login`. In the standalone version this feature comes by default.

After JBoss is started go to http://localhost:8080/nuxeo/site.

==== Requirements

* JBoss 4.0.5 GA
* Nuxeo EP 5.2 - WebEngine is not working with older versions
* Java 5 - WebEngine is also working with Java 6 but other modules in JBoss may not work properly.

== Applications

Now that we've seen the main concepts used to build a web application, we can learn how to configure and assemble them to obtain a working application.
 
A Web  Application is a collection of configuration files, scripts, templates and other resources that are accessible remotely through a servlet. The WebEngine allows the definition of multiple applications. All these application data reside inside the root `web` directory.

An application may access any resources within the root `web` directory, but none outside it. This means that several applications may share data and reuse scripts.

An application is responsible for:
+ Resolving script or templates paths
+ Managing the custom configuration
+ Resolving path segments to documents
+ Managing the scripting and template engine

Web application data may be contributed by separate OSGi modules (JARs). Usually when a module wants to contribute it's own scripts and templates it is installing these files from the JAR inside the `web` root directory (this is done automatically by using an extension point - we will see this later in Configuration chapter).

It is recommended that modules should contribute files by creating a new directory into the `web` root and not by replacing existing files. The directory stacking mechanism can be used to override existing files if this is wanted. 

Applications are useful when you need to deploy multiple sites on the same server or when you want to customize an existing application but don't want your changes to modify the existing application. For example you need to override the document type `File` is handled vut only in your application scope.

When hosting multiple sites using WebEngine it is better to separate these sites in applications rather than using a single application that will correctly dispatch request for each site by using mappings or other techniques. This ensure a better scalability since each application configuration is isolated from the others and each application will use its own cache.

Even if isolated at configuration level, applications may share script, template or static files.

=== Web Engine Servlet

All applications are served by a single servlet - the one that is bound in the web.xml file to the WebEngine. To create a WebEngine servlet you should define it as following (see `web/WEB-INF/web.xml` file):

{{{
  <servlet>
    <servlet-name>Nuxeo WebEngine Servlet</servlet-name>
    <servlet-class>
    org.nuxeo.ecm.webengine.servlet.WebServlet
    </servlet-class>
  </servlet>
}}}

To be able to use the Nuxeo EP repository from WebEngine you should also declare an authentication filter as following (see `web/WEB-INF/web.xml`)

{{{
  <filter>
    <display-name>WebEngine Authentication Filter</display-name>
    <filter-name>WebEngineAuthenticationFilter</filter-name>
    <filter-class>
      org.nuxeo.ecm.webengine.login.WebEngineAuthenticationFilter
    </filter-class>
    <init-param>
      <param-name>exclude</param-name>
      <param-value>/files</param-value>
    </init-param>
  </filter>
}}}

The `exclude` parameter is used to avoid filtering request having paths starting with the `/files` prefix since this prefix is used by WebEngine to locate static files as CSS, script and image files.

=== Application Configuration

Before talking about configuration format you should know that WebEngine is using the Nuxeo extension point mechanism to contribute configuration files.
A Nuxeo component may declare several extension points to let other components contributing custom configuration. These extension points are declared using XML files. Extensions contributed by other modules are also declared as XML files. For more information on how this works see the documentation of Nuxeo EP.

To define a new application you need to contribute a new application extension. This extension can live anywhere where accessible from `nuxeo-webengine-core` bundle (even in a JAR) but we recommend to place configuration files in `web/WEB-INF` directory.

As new applications are usually contributed by new modules (that are installed as JARs) this section will explain how to create a new application from a nuxeo module.

A WebEngine module, apart the configuration files may also deploy script and other resource files in the `web` directory. Here is a a complete example on how to create a new application and deploy new web resources and it is taken from the `nuxeo-webengine-wiki` module. In your module you need to deploy an XML component having a content similar with the following (see `nuxeo-webegine-wiki/OSGI-INF/wiki-deployment-contrib.xml`):

{{{
  <extension
    target="org.nuxeo.ecm.webengine.WebEngineComponent"
    point="install">
      <install guard="/WEB-INF/wiki-webapp.xml">
        <copy path="OSGI-INF/wiki-webapp.xml" target="/WEB-INF/wiki-webapp.xml" />
        <copy path="web/wiki" target="/" />
        <copy path="web/resources" target="/" />
        <append path="web/i18n/messages.properties" target="/i18n/messages.properties"/>
    </install>
  </extension>

  <extension
    target="org.nuxeo.ecm.webengine.WebEngineComponent"
    point="configuration">
      <configuration path="/WEB-INF/wiki-webapp.xml" />
  </extension>
}}}

The first extension point is declaring all the files you want to copy from the JAR in the `web` directory the first time your module is loaded.
The `copy` directive is doing a directory or file copy by overwriting any existing file; the append directive is appending some file on an existing file.

The special `guard` attribute is specifying a file that will act as a guard to prevent re-deploying your web files each time you restart the server.
That is,if the `guard` file already exists, then the file deployment is skipped. This way, the startup time is improved and also you avoid overwriting your manual changes on the already deployed files.

The second extension is declaring the `/WEB-INF/wiki-webapp.xml` as a configuration file. This is also enabling the hot redeployment on that file.
If you don't want hot redeployment on your configuration file you need to add an extra attribute: *trackChanges="false"*

*Note* that it is also possible to deploy new applications without having to install a new JAR. To do this you need to edit an existing configuration file and add your application contribution there or to add a new configuration contribution (that declares your new configuration file). In future this will be improved and we plan to make possible to install and remove applications simply by adding / removing XML files into `web/WEB-INF`.

Now that you deployed you know how to deploy a new application we can look into the application extension point to see how an application can be configured.

Here is an example of an application configuration:

{{{
  <extension target="org.nuxeo.ecm.webengine.WebEngineComponent"
    point="application">
    <webapp id="myapp" extends="default">
      <repository>default</repository>
      <errorPage>error.groovy</errorPage>
      <roots>
        <root priority="0">default</root>
      </roots>
      <mappings>
        <mapping pattern="/search">
          <script>/common/search.ftl</script>
        </mapping>
      </mappings>
    </webapp>

  </extension>
}}}

* `extends` attribute is optional and means that the current application extends the configuration defined for the `default` application.
* `repository` element is used to specify what repository this application will use (if any is used). It defaults to "default"
* `errorPage` element specify a script or template to be used to handle errors. It defaults to "error.ftl". There are also more default pages that you can configure using the elements:
** `indexPage` - called when a root request `/` is made in that application. Defaults to "index.ftl"
** `defaultPage` - called when a resource is not found and the application didn't triggered any error. Defaults to "default.ftl"
* `roots` used to declare the directory roots in that application. See Directory Stacking section for more information.
* `mappings` used to bypass the default mapping mechanism as discussed Path Mapping section. In our example the traversal path that exactly match `/search` will be redirected to the script `/common/searech.ftl`

*Note* that the configuration syntax may change in future.

=== Application Selection

We've seen how to define a new application. But how this application becomes selected for an incoming request?

This is done by defining rules to map request paths to applications.

*Note* that a single application can be mapped to multiple paths.

Here is an example for such a mapping rule:

{{{
  <extension target="org.nuxeo.ecm.webengine.WebEngineComponent"
    point="application-mapping">
    <mapping path="/" webapp="default" />
    <mapping path="/repository" webapp="default" document="/default-domain" default="true" />
    <mapping path="/admin" webapp="admin">
      <permission expression="user=Administrator" />
    </mapping>
  </extension>
}}}

The mapping is done on path prefixes and the longest match win.

The first mapping rule maps the __default__ application to any path that starts with `/` path. This means any requests that is not matched to an application will be handled by the default application.

The second mapping rule maps the __default__ application to any path that starts with `/repository`.

Also the `document` attribute specifies that when this rule matches, the Document root should be set to `/default-domain`.

The `default` attribute is a little bit special. It tells that this mapping rule is the default one when trying to compute document paths.

Imagine in you display on a page the result of a search in the repository. Within the result you may have documents that are outside the scope of your application context. In order to be able to display such documents you need an URL (that your application is not aware of). In that case the `default` mapping rule will be used to compute the document URL.

You can see that the last mapping declared above is containing a permission element. This element is used to have a security check whenever the mapping matches (e.g. a path starting with /admin is requested). In our case the security guard check if the current user is the Administrator. If the check failes a 401 (Unauthorized) error page is returned.


=== Directory Stacking

As we've seen earlier an application may define several roots inside the web root directory.

These roots are known as the application directory stack and are used to resolve scripts and templates.

Root directories are stacked given a priority so that the resolver will try each root in a the right priority order until a resource is found.

Directory Roots are mainly used to override templates and scripts or add new ones from external modules. By using the right priority for the root directories in the stack you may obtain the desired effect - overriding some existing resources without overriding some other ones.

Stacking is inherited when an application extends another application.

==== Example

Let's say module `nuxeo-webengine-core` contributed the `default` directory, `nuxeo-webengine-wiki` contributed the `wiki` directory and `nuxeo-webengine-blogs` the `blogs` directory.

The `wiki` folder contains scripts and templates that deals with `Wiki` and `WikiPage` document types, while the `blogs` folder declare the (FIXME).

Then an application APP1 may use a stack: `wiki`, `default` and another application APP2 may use: `blogs`, `default`.

Both APP1 and APP2  will see the scripts that deal with common Nuxeo types (the ones from `default`) but APP1 will not see blog related scripts and APP2 will not see wiki related scripts.

Using the same mechanism you may change or hide only .css or .gif files creating thus skins.

=== Web Objects

Before talking about Web Objects we will recapitulate some things about traversal paths. We've seen that *request paths* are split into:
* an *application path*
* a *traversal path*
* and optionally a *trailing path*

The `traversal path` if any defines a sequence of documents that should be traversed before executing the request. The last document that is traversed (the last in the traversal object chain) is considered the target document of the request (this may be the root document itself) and the request will be executed in the context of that document.

We've also seen that you may have requests that doesn't generate any traversal path. In this case pure web scripting will be done (outside any document context). Also you should note that the documents in the traversal path are not necessarily the children of each other like in a repository path. The mechanism used to create the traversal path is up to the registered document resolver.

The documents in the traversal path will not be exposed as is in the request context but they will be wrapped inside a high level object - web oriented that is called WebOject. This is needed because the Nuxeo documents are repository oriented, they doesn't have any knowledge about the web context in which they are used. They doesn't know for example what is the URL used to access them, or what are the web actions that are enabled in the current web context.

For this reason before being exposed in the web context they are wrapped in a web sensitive object.

This means we need to map documents to a high level object that can hold web specific configuration like enabled web actions. 

A WebObject is primarily defining a set of actions that are available on the corresponding Document type. Here is an example:

{{{
  <extension target="org.nuxeo.ecm.webengine.WebEngineComponent"
    point="webObject">
    <requestHandler>org.nuxeo.ecm.webengine.DefaultRequestHandler</requestHandler>
    <object id="MyObject" extends="WebObject">
      <actions>
        <action id="view" enabled="true">
          <permission  expression="Read"/>
        </action>
        <action id="edit_page" enabled="true">
          <permission expression="Write" />
          <category>TABVIEW</category>
        </action>
        <action id="permissions_page" enabled="true">
          <permission expression="Write" />
          <category>TABVIEW</category>
        </action>
        <action id="print" enabled="true">
          <permission expression="Read" />
          <category>TOOLBOX</category>
        </action>
        <action id="delete" enabled="true" handler="org.nuxeo.ecm.webengine.actions.DeleteActionHandler">
          <permission expression="Write" />
          <category>TOOLBOX</category>
        </action>
        <action id="search" enabled="true" script="/common/search.ftl">
          <permission expression="Browse" />
        </action>
      </actions>
    </object>
  </extension>
}}}

You can see a that a web object can inherit from another object by using the `extends` attribute. This is useful if you want to avoid redefining generic actions or properties. By extending an existing object you create a new web object definition - you cannot modify the extended object.

You can control the way the request is processed (and the default document mapping method) by using the element: `requestHandler`.
This element is optional and defaults to `org.nuxeo.ecm.webengine.DefaultRequestHandler`.

As you can see the main usage of an Web Object is to define actions. For example the action `delete` has a guard that enable the action only if the current user has the `Write` permission on the target document. And the Java action handler is specified by the `handler` attribute.

Each action has a default handler so usually you don;'t need to define a handler only if you want to set your custom handler. Usually you will want to handle actions using scripts as in the last action defined below: the `search` action will invoke the script `/common.search.ftl` on the target document.

You can learn more about actions in the next section.

To bind a declared Web Object to a document type you need to use the `binding` extension point:

{{{
  <extension target="org.nuxeo.ecm.webengine.WebEngineComponent"
    point="binding">
    <binding type="Document" objectId="WebObject" />
    <binding type="MyDocument" objectId="MyObject" />
  </extension>
}}}

This will bind the `WebObject` object to the `Document` docuemnt type. This is the root of all types in Nuxeo EP - so this binding will be used as a fallback for every document type that is not explicitly bound.

The second declaration will bound the MyDocument type to an object named MyObject.

If you are declaring these bindings inside an application extension (as part of the application configuration) the bindings will be visible only to that application otherwise they are visible to all applications.

*Note* that Web Objects configuration syntax may change in future.

=== Actions

There are several pre-defined actions in the default webengine configuration. Here is a list of that actions:

+ view
+ print
+ edit
+ delete
+ create
+ update
+ getfile
+ addfile
+ deletefile

An action should be identified using a meaningful verb like 'doSomething' and can specify:
* a class to be used as the action handler
* a script to be invoked on the target document
* an enablement flag to be used to disable / enable the action
* a category that can be used to group actions
* a set of guards to restrict the action execution

Any of these action properties are optional - but the action will be useless if you do not specify one of them.

The first 2 properties the *action handler* and the *script* should be used to specify how the action will be executed.

As you seen you have two options: either using java code (if you want faster or advanced processing) either using a script (possibly a template) that will carry on the action execution. 

You can either use both properties to install a Java action execution handler and a template to be used to show the result of the execution. Or, more, you can install a handler and a groovy script then in the groovy script you may do some post processing and then call a template to show the result.

The action category can be used to filter or to group actions. For example, you may want to show only a set of actions that are enabled on a document filtered by a category.

Finally, the guards can be installed to restrict actions to be available only for some users. Guards are very flexible. To define a guard you can use complex logical expressions on other guards. We will name any guard that it is not a logical expression an atomic guard.

Here is a list of all supported atomic guards:

+ Permission Guard - restrict access by testing native Nuxeo EP document permissions.
+ User Guard - restrict access by testing the current user name
+ Group Guard - restrict access by testing the current group name
+ Type Guard - restrict access by testing the current document type
+ Schema Guard - restrict access by testing the presence of a schema in the current document type
+ Facet Guard - restrict access by testing the presence of a facet in the current document type
+ Script Guard - restrict access using random scripts. Any java scripting engine is supported

Example of a logical expression guard: `Write OR (user = foo OR group = bar )`. This means give permission on all users that have the `Write` permission on the document OR to a user named `foo` or all users from group `bar`.  

You can define actions as you want: you can map them to scripts or to Java code - it is up to you how you will use that action.

For how to retrieve available actions on the target document from a script, please refer to the Script Context chapter.

== Configuration

The configuration files are located in the `web/WEB-INF` directory.

The configuration files are hot deployable - this means you can modify the configuration and have your modifications visible without restarting the server. The same is true for any script and template files. The only exception is the `web.xml` file which declares the servlet used by WebEngine when deployed as a standalone servlet.

*Note* that the configuration files syntax may change in future versions.
